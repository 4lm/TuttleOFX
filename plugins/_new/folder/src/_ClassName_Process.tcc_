
namespace tuttle {
namespace plugin {
namespace %NAMESPACE% {

template<class View>
%CLASSNAME%Process<View>::%CLASSNAME%Process( %CLASSNAME%Plugin &instance )
: ImageGilProcessor<View>( instance )
, _plugin( instance )
{
}

template<class View>
void %CLASSNAME%Process<View>::setup( const OFX::RenderArguments &args )
{
	using namespace boost::gil;
	// source view
	boost::scoped_ptr<OFX::Image> src( _plugin.getSrcClip( )->fetchImage( args.time ) );
	if( !src.get( ) )
		throw( ImageNotReadyException( ) );
	this->_srcView = this->getView( src.get(), _plugin.getSrcClip( )->getPixelRod(args.time) );

	// destination view
	boost::scoped_ptr<OFX::Image> dst( _plugin.getDstClip( )->fetchImage( args.time ) );
	if( !dst.get( ) )
	    throw( ImageNotReadyException( ) );
	this->_dstView = this->getView( dst.get(), _plugin.getDstClip( )->getPixelRod(args.time) );

	// Make sure bit depths are same
	if( src->getPixelDepth( ) != dst->getPixelDepth( ) ||
	    src->getPixelComponents( ) != dst->getPixelComponents( ) )
	{
	    throw( BitDepthMismatchException( ) );
	}
}

/**
 * @brief Function called by rendering thread each time 
 *        a process must be done.
 *
 * @param[in] procWindow  Processing window
 */
template<class View>
void %CLASSNAME%Process<View>::multiThreadProcessImages( const OfxRectI& procWindow )
{
	using namespace boost::gil;
	
	View src = subimage_view( this->_srcView, procWindow.x1, procWindow.y1,
							  procWindow.x2 - procWindow.x1,
							  procWindow.y2 - procWindow.y1 );
	View dst = subimage_view( this->_dstView, procWindow.x1, procWindow.y1,
							  procWindow.x2 - procWindow.x1,
							  procWindow.y2 - procWindow.y1 );
	copy_pixels( src, dst );
}

}
}
}
