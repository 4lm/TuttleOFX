import subprocess
import shutil
import cmd
import functools
import os
import sys
import urllib
from pprint import pformat
from pydoc import pager

import util


full_build_order = [
    'materialize',
    'install',
]

libs_dict = {}

def valid_lib_name_list(args):
    '''
    Return a lib name list containing only recognized lib name.
    args is a str list.
    '''
    libs = []
    for name in args:
        if name in libs_dict.keys():
            libs.append(libs_dict[name])

        else:
            print "*Warning* - target lib '{}' not found.".format(name)

    return libs

class Brndo(cmd.Cmd):

    def __init__(self, all_libs):
        cmd.Cmd.__init__(self)
        self.ruler =' '
        self.all_libs = all_libs
        # global libs_dict filling
        for l in self.all_libs:
            libs_dict[l.name] = l

    def help_help(self):
        print "Print the help."

    def help_brndo(self):
        pager(__doc__)

    def do_quit(self, arg, print_ln=False):
        '''
        quit
        Exit program
        '''
        if print_ln:
            print('')
        sys.exit()

    def do_list(self, arg):
        '''
        list
        Print the lib list.
        '''
        if arg:
            print self.do_list.__doc__
            return

        all_libs_status = ""
        for l in self.all_libs:
            all_libs_status += "{}\n".format(l.status())

        pager(all_libs_status)            

    def do_materialize(self, arg):
        '''
        materialize [-v] [lib ...]
        Materialize lib.
          -v  Show command output.
        '''
        libs = self.all_libs
        verbose = False
        if arg:
            args = arg.split()
            if '-v' in args:
                verbose = True
                args.remove('-v')

            if args:
                libs = valid_lib_name_list(args)

        libs = util.update_libs_with_dependencies(libs, self.all_libs)
        graph = {}
        for l in libs:
            graph[l.name] = l.depends_on

        ordered_lib_names = util.order_by_topology(graph) 
        print libs, ordered_lib_names
        
        # for lib in libs:
        #     if verbose:
        #         self.onecmd(" ".join(['materialize -v', lib['name']]))

        #     else:
        #         self.onecmd(" ".join(['materialize', lib['name']]))
        

    def do_install(self, arg):
        '''
        install [-v] [lib ...]
        Install lib.
          -v  Show command output.
        '''
        libs = self.all_libs
        verbose = False
        if arg:
            args = arg.split()
            if '-v' in args:
                verbose = True
                args.remove('-v')

            if args:
                libs = valid_lib_name_list(args)

        for lib in libs:
            if verbose:
                self.onecmd(" ".join(['materialize -v', lib['name']]))

            else:
                self.onecmd(" ".join(['materialize', lib['name']]))

            print "-- \nInstall ", lib['name']
            if not lib.get('install_cmd'):
                print "*Warning* - Install command not specified. (Skipping)"
                continue

            if util.execute_command(lib, 'install_cmd', self.extracted_dir, verbose):
                print "Ok - Installed."

            else:
                print "**ERROR** - Install failed."

    def do_clean(self, arg):
        '''
        clean [-v] [lib ...]
        Clean lib build dir.
          -v  Show command output.
        '''
        libs = self.all_libs
        verbose_output = False
        if arg:
            args = arg.split()
            if '-v' in args:
                verbose_output = True
                args.remove('-v')

            if args:
                libs = valid_lib_name_list(args)

        for lib in libs:
            print "-- \nClean ", lib['name']
            if not lib.get('clean_cmd'):
                print "*Warning* - Clean command not specified. (Skipping)"
                continue

            if util.execute_command(lib, 'clean_cmd', self.extracted_dir, verbose_output):
                print "Ok - Cleaned."

            else:
                print "**ERROR** - Clean failed."

    def do_distclean(self, arg):
        '''
        distclean [-v] [lib ...]
        Delete all files (archive, build directory)
          -v  Show command output.
        '''
        libs = self.all_libs
        verbose_output = False
        if arg:
            args = arg.split()
            if '-v' in args:
                verbose_output = True
                args.remove('-v')

            if args:
                libs = valid_lib_name_list(args)

        for lib in libs:
            print "-- \nDist clean ", lib['name']
            if not lib.get('distclean_cmd'):
                print "*Warning* - Dist clean command not specified. (Skipping)"
                continue

            if util.execute_command(lib, 'clean_cmd', self.extracted_dir, verbose_output):
                print "Ok - Dist cleaned."

            else:
                print "**ERROR** - Dist clean failed"

    # shortcuts
    do_q        = do_quit
    do_EOF      = lambda self, arg: Brndo.do_quit(self, arg, print_ln=True)
