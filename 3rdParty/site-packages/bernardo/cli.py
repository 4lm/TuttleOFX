import subprocess
import shutil
import cmd
import functools
import os
import sys
import urllib
from pprint import pformat
from pydoc import pager

import tool


lib_dict = {
    # lib_name: {'name': libname, 'sha': sha, 'url': url},
}

class Brndo(cmd.Cmd):

    download_dir = "archive"
    extracted_dir = "extracted"
    all_libs = None
    def __init__(self, all_libs, download_dir=None, extracted_dir=None):
        cmd.Cmd.__init__(self)
        self.ruler =' '
        self.all_libs = all_libs
        if download_dir:
            self.download_dir = download_dir
        if extracted_dir:
            self.extracted_dir = extracted_dir

        # lib_dict fill
        for l in self.all_libs:
            lib_dict[l['name']] = l

    def help_help(self):
        print "Print the help."

    def help_brndo(self):
        pager(__doc__)

    def do_quit(self, arg):
        '''
        quit
        Exit program
        '''
        sys.exit()

    def do_list(self, arg):
        '''
        list
        Print the lib list.
        '''
        if arg:
            print self.do_list.__doc__
            return
        pager(pformat(self.all_libs))

    def do_fetch(self, arg):
        '''
        fetch [-f] [lib [...]]
        Fetch lib.
          -f  force fetching
          -n  dry run
          -s download if sha check does't match. 
        '''
        force_fetch = False
        dry_run = False
        check_sha = False
        libs = self.all_libs
        if arg:
            args = arg.split()
            if '-f' in args:
                force_fetch = True
                args.remove('-f')
            if '-n' in args:
                dry_run = True
                args.remove('-n')
            if '-s' in args:
                check_sha = True
                args.remove('-s')

            if len(args):
                libs = []
                for name in args:
                    if name in lib_dict.keys():
                        libs.append(lib_dict[name])
                    else:
                        print "*Warning* - target lib '{}' not found.".format(name)

        def dl_progress(filename, count, block_size, total_size):
            percent = int( count * block_size * 100/total_size )
            progress_bar = '[--------------------]'
            fill = "#" * (count * block_size * (len(progress_bar)-2)/total_size)
            progress_bar = progress_bar.replace('-'*len(fill), fill, 1)
            sys.stdout.write( '\r{} {} % of {}'.format(progress_bar,
                                                         percent, filename))
            if percent >= 100:
                sys.stdout.write('\n')
                sys.stdout.flush()

        for lib in libs:
            print "-- \nFetching ", lib['name'], 'at', lib['url']
            print "dry_run     =", dry_run
            print "force_fetch =", force_fetch
            print "check_sha   =", check_sha
            
            filename = [p for p in lib['url'].split('/')
                        if len(tool.get_known_extensions(p))][0]

            destination_filename = os.path.abspath(os.path.join(self.download_dir,
                                                                os.path.basename(filename)))
            
            if os.path.exists(destination_filename):
                force_fetch_backup = force_fetch
                print("Destination {} alredy exist.".format(destination_filename))
                if check_sha:
                    print "Performing checksum ..."
                    if not tool.shacheck(destination_filename, lib['sha'],
                                         verbose=True):
                        print "Sha does not match."
                        force_fetch = True
                    else:
                        print "Sha match."

                if not force_fetch:
                    print("Skipping download.")
                    continue
                print("Forced download !")
                force_fetch = force_fetch_backup

            if not dry_run:
                if not os.path.exists(self.download_dir):
                    os.makedirs(self.download_dir)
                reporthook = functools.partial(dl_progress, lib['url'])
                urllib.urlretrieve(lib['url'], destination_filename, reporthook)
            print("Ok - File downloaded.")
            
    def do_shacheck(self, arg):
        '''
        shacheck [lib [...]]
        Check lib archive integrity.
        '''
        libs = self.all_libs

        if arg:
            libs = []
            args = arg.split()
            for name in args:
                if name in lib_dict.keys():
                    libs.append(lib_dict[name])
                else:
                    print "*Warning* - target lib '{}' not found.".format(name)

        for lib in libs:
            print "-- \nSHA check", lib['name']
            filename = [p for p in lib['url'].split('/')
                        if len(tool.get_known_extensions(p))][0]

            destination_filename = os.path.abspath(os.path.join(self.download_dir,
                                                                os.path.basename(filename)))
            if os.path.exists(destination_filename):
                print("File {} exist.\n"
                      "Performing check ...".format(destination_filename))
                if not tool.shacheck(destination_filename, lib['sha'],
                                     verbose=True):
                    print "**ERROR** - Sha dont match !"
                else:
                    print "Ok - Sha match."
            else:
                print "**ERROR** - File {} doesn't exist.".format(destination_filename)

    def do_uncompress(self, arg):
        '''
        uncompress [-f] [lib ...]
        Uncompress lib.
          -f Force uncompress (Remove destination folder if already exists)
        '''
        libs = self.all_libs
        force_uncompress = False
        if arg:                
            libs = []
            args = arg.split()
            if '-f' in args:
                force_uncompress = True
                args.remove('-f')

            for name in args:
                if name in lib_dict.keys():
                    libs.append(lib_dict[name])
                else:
                    print "*Warning* - target lib '{}' not found.".format(name)

        for lib in libs:
            print "-- \nUncompress", lib['name']
            print "force_uncompress =", force_uncompress
            filename = [p for p in lib['url'].split('/')
                        if len(tool.get_known_extensions(p))][0]

            archive_filename = os.path.abspath(os.path.join(self.download_dir,
                                                            os.path.basename(filename)))
            if not os.path.exists(archive_filename):
                print "**ERROR** - File {} does not exist.".format(archive_filename)
                continue
            if os.path.isdir(os.path.join(self.extracted_dir, lib['name'])):
                print "*Warning* - {} lib already uncompressed.".format(lib['name'])
                if not force_uncompress:
                    continue
                print "Uncompress forced."
                print "Removing", os.path.join(self.extracted_dir, lib['name'])
                shutil.rmtree(os.path.join(self.extracted_dir, lib['name']))

            tool.uncompress(archive_filename, False, lib['name'], self.extracted_dir)
            print "Ok - Archive uncompressed."

    def do_configure(self, arg):
        '''
        configure [-v] [lib ...]
        Configure lib.
          -v  Show command output.
        '''
        libs = self.all_libs
        verbose_output = False
        if arg:
            libs = []
            args = arg.split()
            if '-v' in args:
                verbose_output = True
                args.remove('-v')

            for name in args:
                if name in lib_dict.keys():
                    libs.append(lib_dict[name])
                else:
                    print "*Warning* - target lib '{}' not found.".format(name)

        if not verbose_output:
            outcmd_file = open('/dev/null', 'w')
        else:
            outcmd_file = sys.stdout

        for lib in libs:
            print "-- \nConfigure ", lib['name']
            if not lib.get('configure_cmd'):
                print "*Warning* - Configure command not specified. (Skipping)"
                continue
            current_dir = os.path.abspath(os.path.curdir)
            os.chdir(os.path.join(self.extracted_dir, lib['name']))
            subprocess.call(lib['configure_cmd'].split(),
                            stdout=outcmd_file,
                            stderr=outcmd_file)
            os.chdir(current_dir)
            print "Ok - Configured."

        if not outcmd_file is sys.stdout:
            outcmd_file.close()

    def do_build(self, arg):
        '''
        build [-v] [lib ...]
        Build lib.
          -v  Show command output.
        '''
        libs = self.all_libs
        verbose_output = False
        if arg:
            libs = []
            args = arg.split()
            if '-v' in args:
                verbose_output = True
                args.remove('-v')

            for name in args:
                if name in lib_dict.keys():
                    libs.append(lib_dict[name])
                else:
                    print "*Warning* - target lib '{}' not found.".format(name)

        if not verbose_output:
            outcmd_file = open('/dev/null', 'w')
        else:
            outcmd_file = sys.stdout

        for lib in libs:
            print "-- \nBuild ", lib['name']
            if not lib.get('build_cmd'):
                print "*Warning* - Build command not specified. (Skipping)"
                continue
            current_dir = os.path.abspath(os.path.curdir)
            os.chdir(os.path.join(self.extracted_dir, lib['name']))
            subprocess.call(lib['build_cmd'].split(),
                            stdout=outcmd_file,
                            stderr=outcmd_file)
            os.chdir(current_dir)
            print "Ok - Built."

        if not outcmd_file is sys.stdout:
            outcmd_file.close()

    def do_install(self, arg):
        '''
        install [-v] [lib ...]
        Install lib.
          -v  Show command output.
        '''
        libs = self.all_libs
        verbose_output = False
        if arg:
            libs = []
            args = arg.split()
            if '-v' in args:
                verbose_output = True
                args.remove('-v')

            for name in args:
                if name in lib_dict.keys():
                    libs.append(lib_dict[name])
                else:
                    print "*Warning* - target lib '{}' not found.".format(name)

        if not verbose_output:
            outcmd_file = open('/dev/null', 'w')
        else:
            outcmd_file = sys.stdout

        for lib in libs:
            print "-- \nInstall ", lib['name']
            if not lib.get('install_cmd'):
                print "*Warning* - Install command not specified. (Skipping)"
                continue
            current_dir = os.path.abspath(os.path.curdir)
            os.chdir(os.path.join(self.extracted_dir, lib['name']))
            subprocess.call(lib['install_cmd'].split(),
                            stdout=outcmd_file,
                            stderr=outcmd_file)
            os.chdir(current_dir)
            print "Ok - Installed."

        if not outcmd_file is sys.stdout:
            outcmd_file.close()

    def do_clean(self, arg):
        '''
        clean [-v] [lib ...]
        Clean lib build dir.
          -v  Show command output.
        '''
        libs = self.all_libs
        verbose_output = False
        if arg:
            libs = []
            args = arg.split()
            if '-v' in args:
                verbose_output = True
                args.remove('-v')

            for name in args:
                if name in lib_dict.keys():
                    libs.append(lib_dict[name])
                else:
                    print "*Warning* - target lib '{}' not found.".format(name)

        if not verbose_output:
            outcmd_file = open('/dev/null', 'w')
        else:
            outcmd_file = sys.stdout

        for lib in libs:
            print "-- \nClean ", lib['name']
            if not lib.get('clean_cmd'):
                print "*Warning* - Clean command not specified. (Skipping)"
                continue
            current_dir = os.path.abspath(os.path.curdir)
            os.chdir(os.path.join(self.extracted_dir, lib['name']))
            subprocess.call(lib['clean_cmd'].split(),
                            stdout=outcmd_file,
                            stderr=outcmd_file)
            os.chdir(current_dir)
            print "Ok - Cleaned."

        if not outcmd_file is sys.stdout:
            outcmd_file.close()

    def do_distclean(self, arg):
        '''
        distclean [-v] [lib ...]
        Delete all files (archive, build directory)
          -v  Show command output.
        '''
        libs = self.all_libs
        verbose_output = False
        if arg:
            libs = []
            args = arg.split()
            if '-v' in args:
                verbose_output = True
                args.remove('-v')

            for name in args:
                if name in lib_dict.keys():
                    libs.append(lib_dict[name])
                else:
                    print "*Warning* - target lib '{}' not found.".format(name)

        if not verbose_output:
            outcmd_file = open('/dev/null', 'w')
        else:
            outcmd_file = sys.stdout

        for lib in libs:
            print "-- \nDist clean ", lib['name']
            if not lib.get('distclean_cmd'):
                print "*Warning* - Dist clean command not specified. (Skipping)"
                continue
            current_dir = os.path.abspath(os.path.curdir)
            os.chdir(os.path.join(self.extracted_dir, lib['name']))
            subprocess.call(lib['distclean_cmd'].split(),
                            stdout=outcmd_file,
                            stderr=outcmd_file)
            os.chdir(current_dir)
            print "Ok - Dist cleaned."

        if not outcmd_file is sys.stdout:
            outcmd_file.close()

    # shortcuts
    do_q        = do_quit
    do_EOF      = do_quit
