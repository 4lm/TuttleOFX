import subprocess
import shutil
import cmd
import functools
import os
import sys
import urllib
from pprint import pformat
from pydoc import pager

import tool


lib_dict = {
    # lib_name: {'name': libname, 'sha': sha, 'url': url},
}

full_build_order = [
    'materialize',
    'install',
]

def valid_lib_name_list(args):
    '''
    Return a lib name list containing only recognized lib name.
    args is a str list.
    '''
    libs = []
    for name in args:
        if name in lib_dict.keys():
            libs.append(lib_dict[name])
        else:
            print "*Warning* - target lib '{}' not found.".format(name)
    return libs

class Brndo(cmd.Cmd):

    download_dir = "archive"
    extracted_dir = "extracted"
    all_libs = None
    def __init__(self, all_libs, download_dir=None, extracted_dir=None):
        cmd.Cmd.__init__(self)
        self.ruler =' '
        self.all_libs = all_libs
        if download_dir:
            self.download_dir = download_dir
        if extracted_dir:
            self.extracted_dir = extracted_dir

        # lib_dict fill
        for l in self.all_libs:
            lib_dict[l.name] = l

    def help_help(self):
        print "Print the help."

    def help_brndo(self):
        pager(__doc__)

    def do_quit(self, arg):
        '''
        quit
        Exit program
        '''
        sys.exit()

    def do_list(self, arg):
        '''
        list
        Print the lib list.
        '''
        if arg:
            print self.do_list.__doc__
            return

        all_libs_status = ""
        for l in self.all_libs:
            all_libs_status += "{}\n".format(l.status())

        pager(all_libs_status)

    def do_fetch(self, arg):
        '''
        fetch [-vfns] [lib [...]]
        Fetch lib.
          -v  verbose output
          -f  force fetching
          -n  dry run
          -s  download if sha check does't match. 
        '''
        verbose = False
        force_fetch = False
        dry_run = False
        check_sha = False
        libs = self.all_libs
        if arg:
            args = arg.split()
            if '-v' in args:
                verbose = True
                args.remove('-v')
            if '-f' in args:
                force_fetch = True
                args.remove('-f')
            if '-n' in args:
                dry_run = True
                args.remove('-n')
            if '-s' in args:
                check_sha = True
                args.remove('-s')
            if args:
                libs = valid_lib_name_list(args)

        def dl_progress(filename, count, block_size, total_size):
            percent = int( count * block_size * 100/total_size )
            progress_bar = '[--------------------]'
            fill = "#" * (count * block_size * (len(progress_bar)-2)/total_size)
            progress_bar = progress_bar.replace('-'*len(fill), fill, 1)
            sys.stdout.write( '\r{} {} % of {}'.format(progress_bar,
                                                         percent, filename))
            if percent >= 100:
                sys.stdout.write('\n')
                sys.stdout.flush()

        for lib in libs:
            print "-- \nFetching ", lib['name'], 'at', lib['url']
            print "dry_run     =", dry_run
            print "force_fetch =", force_fetch
            print "check_sha   =", check_sha
            
            filename = [p for p in lib['url'].split('/')
                        if len(tool.get_known_extensions(p))][0]

            destination_filename = os.path.abspath(os.path.join(self.download_dir,
                                                                os.path.basename(filename)))
            
            if os.path.exists(destination_filename):
                force_fetch_backup = force_fetch
                print("Destination {} alredy exist.".format(destination_filename))
                if check_sha:
                    print "Performing checksum ..."
                    if not tool.shacheck(destination_filename, lib['sha'],
                                         verbose=verbose):
                        print "Sha does not match."
                        force_fetch = True
                    else:
                        print "Sha match."

                if not force_fetch:
                    print("Skipping download.")
                    continue
                print("Forced download !")
                force_fetch = force_fetch_backup

            if not dry_run:
                if not os.path.exists(self.download_dir):
                    os.makedirs(self.download_dir)
                reporthook = None
                if not verbose:
                    reporthook = functools.partial(dl_progress, lib['url'])
                urllib.urlretrieve(lib['url'], destination_filename, reporthook)
            print("Ok - File downloaded.")
            
    def do_shacheck(self, arg):
        '''
        shacheck [-v] [lib [...]]
        Check lib archive integrity.
          -v  Verbose output
        '''
        libs = self.all_libs
        verbose = False
        if arg:
            args = arg.split()
            if '-v' in args:
                verbose = True
                args.remove('-v')
            if args:
                libs = valid_lib_name_list(args)

        for lib in libs:
            print "-- \nSHA check", lib['name']
            filename = [p for p in lib['url'].split('/')
                        if len(tool.get_known_extensions(p))][0]

            destination_filename = os.path.abspath(os.path.join(self.download_dir,
                                                                os.path.basename(filename)))
            if os.path.exists(destination_filename):
                print("File {} exist.\n"
                      "Performing check ...".format(destination_filename))
                if not tool.shacheck(destination_filename, lib['sha'],
                                     verbose=verbose):
                    print "**ERROR** - Sha dont match !"
                else:
                    print "Ok - Sha match."
            else:
                print "**ERROR** - File {} doesn't exist.".format(destination_filename)

    def do_extract(self, arg):
        '''
        extract [-vf] [lib ...]
        Extract lib.
          -v  Verbose output
          -f  Force extract (Remove destination folder if already exists)
        '''
        libs = self.all_libs
        force_extract = False
        verbose = False
        if arg:                
            args = arg.split()
            if '-v' in args:
                verbose = True
                args.remove('-v')
            if '-f' in args:
                force_extract = True
                args.remove('-f')

            if args:
                libs = valid_lib_name_list(args)

        for lib in libs:
            print "-- \nExtract", lib['name']
            print "force_extract =", force_extract
            filename = [p for p in lib['url'].split('/')
                        if len(tool.get_known_extensions(p))][0]

            archive_filename = os.path.abspath(os.path.join(self.download_dir,
                                                            os.path.basename(filename)))
            if not os.path.exists(archive_filename):
                print "**ERROR** - File {} does not exist.".format(archive_filename)
                continue
            if os.path.isdir(os.path.join(self.extracted_dir, lib['name'])):
                print "*Warning* - {} lib already extracted.".format(lib['name'])
                if not force_extract:
                    continue
                print "Extract forced."
                print "Removing", os.path.join(self.extracted_dir, lib['name'])
                shutil.rmtree(os.path.join(self.extracted_dir, lib['name']))

            tool.extract(archive_filename, False, lib['name'], self.extracted_dir)
            print "Ok - Archive extracted."

    def do_install(self, arg):
        '''
        install [-v] [lib ...]
        Install lib.
          -v  Show command output.
        '''
        libs = self.all_libs
        verbose = False
        if arg:
            args = arg.split()
            if '-v' in args:
                verbose = True
                args.remove('-v')

            if args:
                libs = valid_lib_name_list(args)

        for lib in libs:
            if verbose:
                self.onecmd(" ".join(['materialize -v', lib['name']]))
            else:
                self.onecmd(" ".join(['materialize', lib['name']]))

            print "-- \nInstall ", lib['name']
            if not lib.get('install_cmd'):
                print "*Warning* - Install command not specified. (Skipping)"
                continue
            if tool.execute_command(lib, 'install_cmd', self.extracted_dir, verbose):
                print "Ok - Installed."
            else:
                print "**ERROR** - Install failed."

    def do_clean(self, arg):
        '''
        clean [-v] [lib ...]
        Clean lib build dir.
          -v  Show command output.
        '''
        libs = self.all_libs
        verbose_output = False
        if arg:
            args = arg.split()
            if '-v' in args:
                verbose_output = True
                args.remove('-v')

            if args:
                libs = valid_lib_name_list(args)

        for lib in libs:
            print "-- \nClean ", lib['name']
            if not lib.get('clean_cmd'):
                print "*Warning* - Clean command not specified. (Skipping)"
                continue
            if tool.execute_command(lib, 'clean_cmd', self.extracted_dir, verbose_output):
                print "Ok - Cleaned."
            else:
                print "**ERROR** - Clean failed."

    def do_distclean(self, arg):
        '''
        distclean [-v] [lib ...]
        Delete all files (archive, build directory)
          -v  Show command output.
        '''
        libs = self.all_libs
        verbose_output = False
        if arg:
            args = arg.split()
            if '-v' in args:
                verbose_output = True
                args.remove('-v')

            if args:
                libs = valid_lib_name_list(args)

        for lib in libs:
            print "-- \nDist clean ", lib['name']
            if not lib.get('distclean_cmd'):
                print "*Warning* - Dist clean command not specified. (Skipping)"
                continue
            if tool.execute_command(lib, 'clean_cmd', self.extracted_dir, verbose_output):
                print "Ok - Dist cleaned."
            else:
                print "**ERROR** - Dist clean failed"

    # shortcuts
    do_q        = do_quit
    do_EOF      = do_quit
