import os
import sha
import shutil
import subprocess
import sys
import tarfile
import zipfile
from pprint import pprint

def format_lib_as_script(lib, base_lib_dir):
    '''
    Return a string describing a package as a python script.
    None if template file is not found.
    Support Template : v0.1
    '''
    destination_dir = base_lib_dir
    template_filename = os.path.join(destination_dir, '_template.p_')

    if not os.path.exists(template_filename):
        print "**ERROR** - Template file not found."
        return None

    with open(template_filename, 'r') as f:
        template = f.read()

    return template.format(lib_name          = lib.get('name', ''),
                           lib_url           = lib.get('url', ''),
                           lib_sha           = lib.get('sha', ''),
                           lib_depends_on    = lib.get('depends_on', []),
                           # Restoring values that shouldn't be formatted now.
                           name='{}', url='{}', sha='{}',
                           depends_on='{}')

def execute_command(lib, cmd_key, basedir, verbose=False):
    '''
    Execute lib['cmd_key'] command in basedir/lib['name'].
    If verbose is True, print command output on sys.stdout.
    Return True on success, False otherwise.
    '''
    has_no_exception = True
    stdout_file = sys.stdout
    stderr_file = sys.stderr
    current_dir = os.path.abspath(os.path.curdir)
    try:
        if not verbose:
            stdout_file = open('/dev/null', 'w')
            stderr_file = stdout_file

        os.chdir(os.path.join(basedir, lib['name']))
        subprocess.call(lib[cmd_key].split(),
                        stdout=stdout_file,
                        stderr=stderr_file)

    except:
        import traceback
        print "**ERROR** - execute_command exception."
        print traceback.format_exc(sys.exc_info()[2])
        has_no_exception = False

    finally:
        os.chdir(current_dir)
        if stdout_file is not sys.stdout:
            stdout_file.close()

        return has_no_exception

def order_by_topology(graph):
    '''
    Return a graph topology ordered node_name list, if graph has no cycles
    graph is a dict such as {'node_name':['dependency_name', ...], ...}
    
    http://en.wikipedia.org/wiki/Topological_sort
    L <- Empty list that will contain the sorted elements
    S <- Set of all nodes with no incoming edges
    while S is non-empty do
      remove a node n from S
      insert n into L
      for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S
    if graph has edges then
      return error (graph has at least one cycle)
    else 
      return L (a topologically sorted order)
    '''
    graph_copy = dict(graph)
    for n in graph_copy:
        graph_copy[n] = list(graph_copy[n])

    ordered_list = []
    node_without_edges = [n for n in graph_copy if not len(graph_copy[n])]
    while node_without_edges:
        n = node_without_edges.pop()
        ordered_list.append(n)
        for m in [m for m in graph_copy if n in graph_copy[m]]:
            graph_copy[m].remove(n)
            if not graph_copy[m]:
                node_without_edges.append(m)

    graph_has_cycle = False
    for n in graph_copy:
        if graph_copy[n] != []:
            graph_has_cycle = True

    if graph_has_cycle:
        raise RuntimeError("Graph cycle(s) detected.")

    return ordered_list

def test_order_by_topology():
    '''
    Test the order_by_topology function.
    Return True if all tests were successfull, False otherwise.
    '''
    return_value = True
    nodes = {
    'a': ['b', 'c', 'd'],
    'b': ['e'],
    'c': ['e'],
    'd': ['c', 'f'],
    'e': [],
    'f': [],
    }
    print '-- '
    print test_order_by_topology.__doc__
    print "Testing success."
    print "Order graph"
    print '{'
    for n in sorted(nodes.keys()):
        print "  '{node}': {dependencies},".format(node=n, dependencies=nodes[n])

    print '}'
    build_sequence = order_by_topology(nodes)
    print "Testing build sequence", build_sequence
    built_nodes = []
    for n in build_sequence:
        for d in nodes[n]:
            if d not in built_nodes:
                print "**ERROR** - {} dependency from {} not satisfied.".format(n, d)
                print "Built nodes", built_nodes, "remains", [n for n in nodes.keys()
                                                              if n not in built_nodes]
                return_value = False
                break

        built_nodes.append(n)

    if sorted(built_nodes) == sorted(nodes.keys()):
        print "Ok - All nodes were succesffully built."

    #test with cycling graph
    nodes = {
        'a': ['b', 'c', 'd'],
        'b': ['e'],
        'c': ['e'],
        'd': ['c', 'f'],
        'e': ['a'],
        'f': [],
        }
    print "Testing Failure."
    print "Graph"
    print '{'
    for n in sorted(nodes.keys()):
        print "  '{node}': {dependencies},".format(node=n, dependencies=nodes[n])
    print '}'

    try:
        build_sequence = order_by_topology(nodes)

    except RuntimeError, e:
        print 'Ok - exception', e
        return return_value

    print '**ERROR** - No exception raised.'
    return_value = False
    return return_value
    
def shacheck(filename, sha_str, verbose=False):
    '''
    Compute SHA1 for filename and compare it to sha_str.
    Return True if sha match, False otherwise.
    '''
    with open(filename, 'rb') as f:
        current_sha = sha.sha(f.read()).hexdigest()

    if verbose:
        print "Sha Expected :", sha_str
        print "Sha Current  :", current_sha

    if current_sha == sha_str:
        return True

    return False

def get_known_extensions(filename):
    known_extensions = [
        'tar',
        'tar.gz', 'tgz',
        'tar.bz2',
        'zip',
        'exe',
        ]
    return [f for f in known_extensions if filename.endswith(f)]

def extract(filename, in_new_directory, libname, folder):
    ext = get_known_extensions(filename)[0]

    if ext == 'tar.gz' :
        tar = tarfile.open(filename, 'r:*')
        tar.extractall(folder)
        out_dir = tar.getnames()[0]
        
    if ext == 'tar.bz2' :
        tar = tarfile.open(filename, 'r:*')
        tar.extractall(folder)
        out_dir = tar.getnames()[0]

    if ext == 'tgz' :
        tar = tarfile.open(filename, 'r:*')
        tar.extractall(folder)
        out_dir = tar.getnames()[0]
        
    if ext == 'zip' :
        zip = zipfile.ZipFile(filename, 'r')
        if in_new_directory == True : folder += filename[:-len(ext)-1]
        zip.extractall( folder )
        out_dir = zip.namelist()[0]

    if ext == 'exe' :
        fileToRun = filename + ".exe"
        os.startfile( fileToRun )

    if not os.path.exists(os.path.join(os.getcwd(), folder, libname)):
        os.mkdir(os.path.join(os.getcwd(), folder, libname))

    if not os.path.isdir(os.path.join(folder, out_dir)):
        out_dir = os.path.dirname(out_dir)

    if out_dir != libname:
        if os.path.exists(os.path.join(folder, libname)):
            shutil.rmtree(os.path.join(folder, libname))

        os.rename(os.path.join(folder, out_dir),
                  os.path.join(folder, libname))

if __name__ == "__main__":
    if test_order_by_topology():
        print "Tests Ok."
    else:
        print "Tests Failed."
