import sha

def order_by_topology(graph):
    '''
    Return a graph topology ordered node_name list, if graph has no cycles
    graph is a dict such as {'node_name':['dependency_name', ...], ...}
    
    http://en.wikipedia.org/wiki/Topological_sort
    L <- Empty list that will contain the sorted elements
    S <- Set of all nodes with no incoming edges
    while S is non-empty do
      remove a node n from S
      insert n into L
      for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S
    if graph has edges then
      return error (graph has at least one cycle)
    else 
      return L (a topologically sorted order)
    '''
    graph_copy = dict(graph)
    for n in graph_copy:
        graph_copy[n] = list(graph_copy[n])

    ordered_list = []
    node_without_edges = [n for n in graph_copy if not len(graph_copy[n])]
    while node_without_edges:
        n = node_without_edges.pop()
        ordered_list.append(n)
        for m in [m for m in graph_copy if n in graph_copy[m]]:
            graph_copy[m].remove(n)
            if not graph_copy[m]:
                node_without_edges.append(m)

    graph_has_cycle = False
    for n in graph_copy:
        if graph_copy[n] != []:
            graph_has_cycle = True

    if graph_has_cycle:
        raise RuntimeError("Graph cycle(s) detected.")

    return ordered_list

def test_order_by_topology():
    '''
    TODO
    '''
    nodes = {
    'a': ['b', 'c', 'd'],
    'b': ['e'],
    'c': ['e'],
    'd': ['c', 'f'],
    'e': [],
    'f': [],
    }

    ordered_list = sorted(nodes.keys())
    print ordered_list
    print order_by_topology(nodes)
    print nodes
    #todo test build sequence
    #test with cycling graph
    nodes = {
        'a': ['b', 'c', 'd'],
        'b': ['e'],
        'c': ['e'],
        'd': ['c', 'f'],
        'e': ['a'],
        'f': [],
        }
    
def shacheck(filename, sha_str, verbose=False):
    '''
    Compute SHA1 for filename and compare it to sha_str.
    Return True if sha match, False otherwise.
    '''
    with open(filename, 'rb') as f:
        current_sha = sha.sha(f.read()).hexdigest()
    if verbose:
        print "Sha Expected :", sha_str
        print "Sha Current  :", current_sha
    if current_sha == sha_str:
        return True
    return False

def get_known_extensions( filename ):
    known_extensions = {
        'tar':     'tar xf',
        'tar.gz':  'tar xfz',
        'tgz':     'tar xfz',
        'tar.bz2': 'tar xfj',
        'zip':     'unzip',
        'exe':      '',
        }
    return [f for f in known_extensions.keys() if filename.endswith(f)]

def uncompress(filename, ext, in_new_directory, libname, folder):
    if ext == 'tar.gz' :
        tar = tarfile.open( download_dir + "/" + filename, 'r:*')
        tar.extractall( folder )
        out_dir = tar.getnames()[0]
        
    if ext == 'tar.bz2' :
        tar = tarfile.open( download_dir + "/" + filename, 'r:*')
        tar.extractall( folder )
        out_dir = tar.getnames()[0]

    if ext == 'tgz' :
        tar = tarfile.open( download_dir + "/" + filename, 'r:*')
        tar.extractall( folder )
        out_dir = tar.getnames()[0]
        
    if ext == 'zip' :
        zip = zipfile.ZipFile( download_dir + "/" + filename, 'r' )
        if in_new_directory == True : folder += filename[:-len(ext)-1]
        zip.extractall( folder )
        out_dir = zip.namelist()[0]

    if ext == 'exe' :
        fileToRun = download_dir + "/" + filename + ".exe"
        os.startfile( fileToRun )

    if not os.path.exists( os.path.join( os.getcwd(), folder, libname)):
        os.mkdir(os.path.join( os.getcwd(), folder, libname))

    print ('\nuncompress : %s\n ' % libname )

    if not os.path.isdir(os.path.join(folder, out_dir)):
        out_dir = os.path.dirname(out_dir)

    if out_dir != libname:
        if os.path.exists(os.path.join(folder, libname)):
            rmtree(os.path.join(folder, libname))

        os.rename(os.path.join(folder, out_dir),
                  os.path.join(folder, libname))

    print ('end of uncompress\n')
