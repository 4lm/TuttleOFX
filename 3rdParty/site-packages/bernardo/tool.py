import os
import sha
import shutil
import subprocess
import sys
import tarfile
import zipfile


def execute_command(lib, cmd_key, basedir, verbose=False):
    '''
    Execute lib['cmd_key'] command in basedir/lib['name'].
    If verbose is True, print command output on sys.stdout.
    Return True on success, False otherwise.
    '''
    has_no_exception = True
    stdout_file = sys.stdout
    current_dir = os.path.abspath(os.path.curdir)
    try:
        if not verbose:
            stdout_file = open('/dev/null', 'w')

        os.chdir(os.path.join(basedir, lib['name']))
        subprocess.call(lib[cmd_key].split(),
                        stdout=stdout_file,
                        stderr=stdout_file)
    except:
        import traceback
        print "**ERROR** - execute_command exception."
        print traceback.format_exc(sys.exc_info()[2])
        has_no_exception = False
    finally:
        os.chdir(current_dir)
        if stdout_file is not sys.stdout:
            stdout_file.close()
        return has_no_exception

def order_by_topology(graph):
    '''
    Return a graph topology ordered node_name list, if graph has no cycles
    graph is a dict such as {'node_name':['dependency_name', ...], ...}
    
    http://en.wikipedia.org/wiki/Topological_sort
    L <- Empty list that will contain the sorted elements
    S <- Set of all nodes with no incoming edges
    while S is non-empty do
      remove a node n from S
      insert n into L
      for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S
    if graph has edges then
      return error (graph has at least one cycle)
    else 
      return L (a topologically sorted order)
    '''
    graph_copy = dict(graph)
    for n in graph_copy:
        graph_copy[n] = list(graph_copy[n])

    ordered_list = []
    node_without_edges = [n for n in graph_copy if not len(graph_copy[n])]
    while node_without_edges:
        n = node_without_edges.pop()
        ordered_list.append(n)
        for m in [m for m in graph_copy if n in graph_copy[m]]:
            graph_copy[m].remove(n)
            if not graph_copy[m]:
                node_without_edges.append(m)

    graph_has_cycle = False
    for n in graph_copy:
        if graph_copy[n] != []:
            graph_has_cycle = True

    if graph_has_cycle:
        raise RuntimeError("Graph cycle(s) detected.")

    return ordered_list

def test_order_by_topology():
    '''
    TODO
    '''
    nodes = {
    'a': ['b', 'c', 'd'],
    'b': ['e'],
    'c': ['e'],
    'd': ['c', 'f'],
    'e': [],
    'f': [],
    }

    ordered_list = sorted(nodes.keys())
    print ordered_list
    print order_by_topology(nodes)
    print nodes
    #todo test build sequence
    #test with cycling graph
    nodes = {
        'a': ['b', 'c', 'd'],
        'b': ['e'],
        'c': ['e'],
        'd': ['c', 'f'],
        'e': ['a'],
        'f': [],
        }
    
def shacheck(filename, sha_str, verbose=False):
    '''
    Compute SHA1 for filename and compare it to sha_str.
    Return True if sha match, False otherwise.
    '''
    with open(filename, 'rb') as f:
        current_sha = sha.sha(f.read()).hexdigest()
    if verbose:
        print "Sha Expected :", sha_str
        print "Sha Current  :", current_sha
    if current_sha == sha_str:
        return True
    return False

def get_known_extensions(filename):
    known_extensions = [
        'tar',
        'tar.gz', 'tgz',
        'tar.bz2',
        'zip',
        'exe',
        ]
    return [f for f in known_extensions if filename.endswith(f)]

def uncompress(filename, in_new_directory, libname, folder):
    ext = get_known_extensions(filename)[0]

    if ext == 'tar.gz' :
        tar = tarfile.open(filename, 'r:*')
        tar.extractall(folder)
        out_dir = tar.getnames()[0]
        
    if ext == 'tar.bz2' :
        tar = tarfile.open(filename, 'r:*')
        tar.extractall(folder)
        out_dir = tar.getnames()[0]

    if ext == 'tgz' :
        tar = tarfile.open(filename, 'r:*')
        tar.extractall(folder)
        out_dir = tar.getnames()[0]
        
    if ext == 'zip' :
        zip = zipfile.ZipFile(filename, 'r')
        if in_new_directory == True : folder += filename[:-len(ext)-1]
        zip.extractall( folder )
        out_dir = zip.namelist()[0]

    if ext == 'exe' :
        fileToRun = filename + ".exe"
        os.startfile( fileToRun )

    if not os.path.exists(os.path.join(os.getcwd(), folder, libname)):
        os.mkdir(os.path.join(os.getcwd(), folder, libname))

    if not os.path.isdir(os.path.join(folder, out_dir)):
        out_dir = os.path.dirname(out_dir)

    if out_dir != libname:
        if os.path.exists(os.path.join(folder, libname)):
            shutil.rmtree(os.path.join(folder, libname))

        os.rename(os.path.join(folder, out_dir),
                  os.path.join(folder, libname))
