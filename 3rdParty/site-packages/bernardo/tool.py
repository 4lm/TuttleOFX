
def order_by_topology(graph):
    '''
    Return a graph topology ordered node_name list, if graph has no cycles
    graph is a dict such as {'node_name':['dependency_name', ...], ...}
    
    http://en.wikipedia.org/wiki/Topological_sort
    L <- Empty list that will contain the sorted elements
    S <- Set of all nodes with no incoming edges
    while S is non-empty do
      remove a node n from S
      insert n into L
      for each node m with an edge e from n to m do
        remove edge e from the graph
        if m has no other incoming edges then
            insert m into S
    if graph has edges then
      return error (graph has at least one cycle)
    else 
      return L (a topologically sorted order)
    '''
    graph_copy = dict(graph)
    for n in graph_copy:
        graph_copy[n] = list(graph_copy[n])

    ordered_list = []
    node_without_edges = [n for n in graph_copy if not len(graph_copy[n])]
    while node_without_edges:
        n = node_without_edges.pop()
        ordered_list.append(n)
        for m in [m for m in graph_copy if n in graph_copy[m]]:
            graph_copy[m].remove(n)
            if not graph_copy[m]:
                node_without_edges.append(m)

    graph_has_cycle = False
    for n in graph_copy:
        if graph_copy[n] != []:
            graph_has_cycle = True

    if graph_has_cycle:
        raise RuntimeError("Graph cycle(s) detected.")

    return ordered_list

def test_order_by_topology():
    '''
    TODO
    '''
    nodes = {
    'a': ['b', 'c', 'd'],
    'b': ['e'],
    'c': ['e'],
    'd': ['c', 'f'],
    'e': [],
    'f': [],
    }

    ordered_list = sorted(nodes.keys())
    print ordered_list
    print order_by_topology(nodes)
    print nodes
    #todo test build sequence
    #test with cycling graph
    nodes = {
        'a': ['b', 'c', 'd'],
        'b': ['e'],
        'c': ['e'],
        'd': ['c', 'f'],
        'e': ['a'],
        'f': [],
        }
    
